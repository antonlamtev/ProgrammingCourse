\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{cmap}					% поиск в PDF
\usepackage{mathtext} 				% русские буквы в формулах
%\usepackage{tikz-uml}               % uml диаграммы

% Генератор текста
\usepackage{blindtext}

%------------------------------------------------------------------------------

% Подсветка синтаксиса
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
 
 % Цвета для кода
\definecolor{string}{HTML}{B40000} % цвет строк в коде
\definecolor{comment}{HTML}{008000} % цвет комментариев в коде
\definecolor{keyword}{HTML}{1A00FF} % цвет ключевых слов в коде
\definecolor{morecomment}{HTML}{8000FF} % цвет include и других элементов в коде
\definecolor{captiontext}{HTML}{FFFFFF} % цвет текста заголовка в коде
\definecolor{captionbk}{HTML}{999999} % цвет фона заголовка в коде
\definecolor{bk}{HTML}{FFFFFF} % цвет фона в коде
\definecolor{frame}{HTML}{999999} % цвет рамки в коде
\definecolor{brackets}{HTML}{B40000} % цвет скобок в коде
 
 % Настройки отображения кода
\lstset{
language=C, % Язык кода по умолчанию
morekeywords={*,...}, % если хотите добавить ключевые слова, то добавляйте
 % Цвета
keywordstyle=\color{keyword}\ttfamily\bfseries,
stringstyle=\color{string}\ttfamily,
commentstyle=\color{comment}\ttfamily\itshape,
morecomment=[l][\color{morecomment}]{\#}, 
 % Настройки отображения     
breaklines=true, % Перенос длинных строк
basicstyle=\ttfamily\footnotesize, % Шрифт для отображения кода
backgroundcolor=\color{bk}, % Цвет фона кода
%frame=lrb,xleftmargin=\fboxsep,xrightmargin=-\fboxsep, % Рамка, подогнанная к заголовку
frame=tblr
rulecolor=\color{frame}, % Цвет рамки
tabsize=3, % Размер табуляции в пробелах
showstringspaces=false,
 % Настройка отображения номеров строк. Если не нужно, то удалите весь блок
numbers=left, % Слева отображаются номера строк
stepnumber=1, % Каждую строку нумеровать
numbersep=5pt, % Отступ от кода 
numberstyle=\small\color{black}, % Стиль написания номеров строк
 % Для отображения русского языка
extendedchars=true,
literate={Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}1
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
  {~}{{\textasciitilde}}1
  {а}{{\selectfont\char224}}1
  {б}{{\selectfont\char225}}1
  {в}{{\selectfont\char226}}1
  {г}{{\selectfont\char227}}1
  {д}{{\selectfont\char228}}1
  {е}{{\selectfont\char229}}1
  {ё}{{\"e}}1
  {ж}{{\selectfont\char230}}1
  {з}{{\selectfont\char231}}1
  {и}{{\selectfont\char232}}1
  {й}{{\selectfont\char233}}1
  {к}{{\selectfont\char234}}1
  {л}{{\selectfont\char235}}1
  {м}{{\selectfont\char236}}1
  {н}{{\selectfont\char237}}1
  {о}{{\selectfont\char238}}1
  {п}{{\selectfont\char239}}1
  {р}{{\selectfont\char240}}1
  {с}{{\selectfont\char241}}1
  {т}{{\selectfont\char242}}1
  {у}{{\selectfont\char243}}1
  {ф}{{\selectfont\char244}}1
  {х}{{\selectfont\char245}}1
  {ц}{{\selectfont\char246}}1
  {ч}{{\selectfont\char247}}1
  {ш}{{\selectfont\char248}}1
  {щ}{{\selectfont\char249}}1
  {ъ}{{\selectfont\char250}}1
  {ы}{{\selectfont\char251}}1
  {ь}{{\selectfont\char252}}1
  {э}{{\selectfont\char253}}1
  {ю}{{\selectfont\char254}}1
  {я}{{\selectfont\char255}}1
  {А}{{\selectfont\char192}}1
  {Б}{{\selectfont\char193}}1
  {В}{{\selectfont\char194}}1
  {Г}{{\selectfont\char195}}1
  {Д}{{\selectfont\char196}}1
  {Е}{{\selectfont\char197}}1
  {Ё}{{\"E}}1
  {Ж}{{\selectfont\char198}}1
  {З}{{\selectfont\char199}}1
  {И}{{\selectfont\char200}}1
  {Й}{{\selectfont\char201}}1
  {К}{{\selectfont\char202}}1
  {Л}{{\selectfont\char203}}1
  {М}{{\selectfont\char204}}1
  {Н}{{\selectfont\char205}}1
  {О}{{\selectfont\char206}}1
  {П}{{\selectfont\char207}}1
  {Р}{{\selectfont\char208}}1
  {С}{{\selectfont\char209}}1
  {Т}{{\selectfont\char210}}1
  {У}{{\selectfont\char211}}1
  {Ф}{{\selectfont\char212}}1
  {Х}{{\selectfont\char213}}1
  {Ц}{{\selectfont\char214}}1
  {Ч}{{\selectfont\char215}}1
  {Ш}{{\selectfont\char216}}1
  {Щ}{{\selectfont\char217}}1
  {Ъ}{{\selectfont\char218}}1
  {Ы}{{\selectfont\char219}}1
  {Ь}{{\selectfont\char220}}1
  {Э}{{\selectfont\char221}}1
  {Ю}{{\selectfont\char222}}1
  {Я}{{\selectfont\char223}}1
  {і}{{\selectfont\char105}}1
  {ї}{{\selectfont\char168}}1
  {є}{{\selectfont\char185}}1
  {ґ}{{\selectfont\char160}}1
  {І}{{\selectfont\char73}}1
  {Ї}{{\selectfont\char136}}1
  {Є}{{\selectfont\char153}}1
  {Ґ}{{\selectfont\char128}}1
  {\{}{{{\color{brackets}\{}}}1 % Цвет скобок {
  {\}}{{{\color{brackets}\}}}}1 % Цвет скобок }
}
 
 % Для настройки заголовка кода
\usepackage{caption}
\DeclareCaptionFont{white}{\color{сaptiontext}}
\DeclareCaptionFormat{listing}{\parbox{\linewidth}{\colorbox{сaptionbk}{\parbox{\linewidth}{#1#2#3}}\vskip-4pt}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\renewcommand{\lstlistingname}{Код} % Переименование Listings в нужное именование структуры


%------------------------------------------------------------------------------

\author{А.~Ю.~Ламтев}
\title{Программирование}
\begin{document}
\maketitle
\tableofcontents{}

\chapter{Основные конструкции языка}
%############################################################
\section{Задание 1. Размен}
\subsection{Задание}
\hspace{\parindent}
Пользователь задает сумму денег в рублях, меньшую 100 (например, 16). Определить, как выдать эту сумму монетами по 5, 2 и 1 рубль, израсходовав наименьшее количество монет (например, 3 х 5р + 0 х 2р + 1 х 1р).
\subsection{Теоретические сведения}

%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
\hspace{\parindent}
При разработке приложения были задействованы следующие конструкции языка: оператор \textbf{switch}, структуры данных \textit{\textbf{struct}}, макросы препроцессора -- и были использованы функции стандартной библиотеки \textit{printf}, \textit{scanf} и \textit{puts}, определённые в заголовочном файле \textit{stdio.h}; \textit{atoi}, определённая в \textit{stdlib.h}. 

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
\hspace{\parindent}
Я решил, что разменять сумму денег монетами номиналом 5, 2 и 1 руб. наиболее оптимально можно следующим образом. Необходимо, чтобы монет большего номинала было больше, чем монет меньшего номинала, насколько это возможно. Это послужило основой для реализации алгоритма.

\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
\hspace{\parindent}
В ходе проектирования было решено выделить пять функций, одна из которых отвечает за логику, а остальные за взаимодействие с пользователем.
\begin{enumerate}
\item \textbf{Логика}
\begin{itemize}
\item \verb-change_by_coins-

Эта функция вычисляет результат. Она содержит один целочисленный параметр - сумму денег, которую необходимо разменять. Возвращаемое значение имеет структурный тип, который включает 3 целочисленных поля: число монеток в 5 руб, число монеток в 2 руб и число монеток в 1 руб.
\end{itemize}
\textbf{\item Взаимодействие с пользователем}
\begin{itemize}
\item \verb-exchange_output-

Эта функция выводит в консоль результат функции \textit{change\_by\_coins}. Она содержит один параметр структурного типа, который включает 3 целочисленных поля: число монеток в 5 руб, число монеток в 2 руб и число монеток в 1 руб. Возвращаемое значение имеет тип \textbf{\textit{void}}.
\end{itemize}

\begin{itemize}
\item \verb-help_exchange-

Эта функция выводит в консоль информацию о том, как запускать приложение \textbf{Размен} из параметров командной строки. Она не имеет параметров и возвращает пустое значение.
\end{itemize}
\begin{itemize}
\item \verb-exchange_parameters-

Эта функция отвечает за взаимодействие с пользователем при чтении данных из параметров командной строки. Она содержит 2 параметра: типа \textbf{\textit{int}} - количество аргументов командной строки и типа \textbf{\textit{char**}} - массив, содержащий эти аргументы. Считывает данные из параметров командной строки. Вызывает функцию \textit{exchange\_output}, которая в свою очередь выводит в консоль результат. Возвращает пустое значение.
\end{itemize}
\begin{itemize}
\item \verb-exchange-

Эта функция отвечает за взаимодействие с пользователем в интерактивном режиме. Она не имеет параметров. Выводит в консоль сообщение о том, что нужно ввести число. Осуществляет контролируемый ввод данных. Вызывает функцию \textit{exchange\_output}, которая уже и выводит в консоль результат. Возвращает пустое значение.
\end{itemize}
\end{enumerate}
\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.

\begin{flushleft}
\textbf{Интегрированная среда разработки:} Qt Creator 3.5.0 (opensource)

\textbf{Компилятор:} GCC 4.9.1 20140922 (Red Hat 4.9.1-10)

\textbf{Операционная система:} Debian GNU/Linux 8 (jessie) 32-бита (version 3.14.1)
\end{flushleft}
%Ручное тестирование, автоматическое, статический анализ кода, динамический.

На всех стадиях разработки приложения проходило тестирование, ручное и автоматическое. Последнее осуществлялось посредством модульных тестов \textit{Qt}, основанных на библиотеке  \textit{QTestLib}.

На финальной стадии был проведён статический анализ с помощью утилиты \textit{cppcheck}% и динамический анализ с помощью утилиты \textit{valgrid}.
\subsection{Тестовый план и результаты тестирования}
%Описание по шагам хода тестирования, с указанием соответствия или несоответствия ожидаемым результатам.
\begin{enumerate}
\item \textbf{Ручные тесты}
\begin{description}
\item[I тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:] 11
\item[Выходные данные:] 2 0 1
\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\begin{description}
\item[II тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:] 3
\item[Выходные данные:] 0 1 1
\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\item \textbf{Модульные тесты \textit{Qt}}
\begin{description}
\item[I тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:] 28
\item[Выходные данные:] 5 1 1
\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\begin{description}
\item[II тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:] 44
\item[Выходные данные:] 8 2 0
\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\item \textbf{Статический анализ \textit{cppcheck}}

Утилита \textit{cppcheck} не выявила ошибок.
\end{enumerate}
\subsection{Выводы}
%Слова от чистого сердца
\hspace{\parindent}
В ходе выполнения работы я получил опыт создания многомодульного приложения с отделением логики от взаимодействия с пользователем. Укрепил навыки в создании структурных типов. А также научился тестировать программу с помощью модульных тестов и анализировать с помощью утилиты \textit{cppcheck}.
\subsection*{Листинги}
\begin{itemize}
\item[] \verb-exchange.h-
\lstinputlisting[]
{../sources/subdirproject/lib_c/exchange.h}
\item[] \verb-exchange_of_coins_process.c-
\lstinputlisting[]
{../sources/subdirproject/lib_c/exchange_of_coins_process.c}
\item[] \verb-exchange_ui.c-
\lstinputlisting[]
{../sources/subdirproject/app_c/exchange_ui.c}
\end{itemize}

%\todo[inline]{Не забыть вставить все исходники}
%##################################################################################################################################################
%
%##################################################################################################################################################

\section{Задание 2. Ферзи}

\subsection{Задание}
\hspace{\parindent}
На шахматной доске стоят три ферзя (ферзь бьет по вертикали, горизонтали и диагоналям). Найти те пары из них, которые угрожают друг другу. Координаты ферзей вводить целыми числами.
\subsection{Теоретические сведения}
%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
\hspace{\parindent}
При разработке приложения были задействованы следующие конструкции языка: операторы ветвления \textbf{if} и \textbf{if-else-if}, оператор \textbf{switch}, оператор цикла с постусловием \textbf{do-while}, структуры данных \textbf{\textit{struct}} и перечисления \textit{\textbf{enum}} -- и были использованы функции стандартной библиотеки \textit{printf}, \textit{scanf}, \textit{puts}, определенные в заголовочном файле \textit{stdio.h}; функции \textit{abs} и \textit{atoi}, определенные в \textit{stdlib.h}.

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
\hspace{\parindent}
Сведения о том, что ферзь бьет по вертикали, горизонтали или диагоналям, стали основой для реализации алгоритма. Я понял, что два ферзя бьют друг друга в двух случаях: когда они находятся на одной вертикали или горизонатали, а значит у них есть общая соответственная координата, или когда они находятся на одной диагоняли, т.е расстояние между их соответственными координатами одинаково.
\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
\hspace{\parindent}
В ходе проектирования было решено выделить семь функций, две из которых отвечают за логику, а остальные за взаимодействие с пользователем.
\begin{enumerate}
\item \textbf{Логика}
\begin{itemize}
\item \verb-check_for_beating-

Эта функция вычисляет, бьют два ферзя друг друга или нет. Имеет два параметра (2 ферзя) структурного типа, объединяющего два целочисленных поля - две координаты ферзя. Тип возвращаемого значения -- \textit{\textbf{int}} -- 1, если два ферзя бьют друг друга, и 0 -- в противном случае.
\end{itemize}

\begin{itemize}
\item \verb-queens_result-

Эта функция определяет, какой ферзь, кого бьет. Имеет три параметра (3 ферзя) структурного типа, объединяющего два целочисленных поля - две координаты ферзя. Далее она несколько раз вызывает функцию \textit{check\_for\_beating} и для каждой пары ферзей вычисляет резултат. Возвращаемое значение имеет тип \textbf{\textit{int}} -- один элемент из перечисления \textit{\textbf{enum}}, название которого характеризует результат.
\end{itemize}

\textbf{\item Взаимодействие с пользователем}

\begin{itemize}
\item \verb-input_with_check-

Эта функция осуществляет контролируемый ввод из консоли координат ферзя. Имеет два параметра типа \textit{\textbf{int}} - две координаты ферзя. Возвращает пустое значение.
\end{itemize}
\begin{itemize}
\item \verb-display_result-

Эта функция выводит в консоль результат функции \textit{queens\_result}. Она принимает один параметр типа \textit{\textbf{int}} -- один элемент из перечисления \textit{\textbf{enum}}, название которого характеризует результат. Возвращаемое значение имеет тип \textit{\textbf{void}}.
\end{itemize}

\begin{itemize}
\item \verb-help_queens-

Эта функция выводит в консоль информацию о том, как запускать приложение \textbf{Ферзи} из параметров командной строки. Она не имеет параметров и возвращает пустое значение. 
\end{itemize}

\begin{itemize}
\item \verb-queens_parameters-

Эта функция отвечает за взаимодействие с пользователем при вводе данных через параметры командной строки. Она содержит 2 параметра: типа \textbf{\textit{int}} - количество аргументов командной строки и типа \textbf{\textit{char**}} - массив, содержащий эти аргументы. Считывает данные из параметров командной строки. Вызывает функцию \textit{display\_result}, которая выводит результат в консоль. Возвращаемое значение - \textit{\textbf{void}}.
\end{itemize}

\begin{itemize}
\item \verb-queens-

Эта функция отвечает за взаимодействие с пользователем при запуске приложения в интерактивном режиме. Она не имеет параметров. Считывает данные из консоли с помощью функции \textit{input\_with\_check}. Затем вызывает функцию %
\textit{display\_result}, которая выводит результат в консоль. Возвращаемое значение - \textit{\textbf{void}}.
\end{itemize}
\end{enumerate}
\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.

\begin{flushleft}
\textbf{Интегрированная среда разработки:} Qt Creator 3.5.0 (opensource)

\textbf{Компилятор:} GCC 4.9.1 20140922 (Red Hat 4.9.1-10)

\textbf{Операционная система:} Debian GNU/Linux 8 (jessie) 32-бита (version 3.14.1)
\end{flushleft}
%Ручное тестирование, автоматическое, статический анализ кода, динамический.

На всех стадиях разработки приложения проходило тестирование, ручное и автоматическое. Последнее осуществлялось посредством модульных тестов \textit{Qt}, основанных на библиотеке  \textit{QTestLib}.

На финальной стадии был проведён статический анализ с помощью утилиты \textit{cppcheck}% и динамический анализ с помощью утилиты \textit{valgrid}.
\subsection{Тестовый план и результаты тестирования}
%Описание по шагам хода тестирования, с указанием соответствия или несоответствия ожидаемым результатам.
\begin{enumerate}
\item \textbf{Ручные тесты}
\begin{description}
\item[I тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:] 3 1 4 8 2 2
\item[Выходные данные:] no\_one
\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\begin{description}
\item[II тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:] 4 4 8 2 7 7
\item[Выходные данные:] OneThree
\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\item \textbf{Модульные тесты \textit{Qt}}
\begin{description}
\item[I тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:] 1 2 3 4 5 6
\item[Выходные данные:] everyone
\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\begin{description}
\item[II тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:] 1 6 2 6 1 3
\item[Выходные данные:] OneTwo\_OneThree
\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\item \textbf{Статический анализ \textit{cppcheck}}

Утилита \textit{cppcheck} не выявила ошибок.
\end{enumerate}

\subsection{Выводы}
В ходе выполнения работы я получил опыт создания многомодульного приложения с отделением логики от взаимодействия с пользователем. Впервые использовал перечисления \textit{\textbf{enum}}, что оказалось очень удобно. Укрепил навыки в создании структурных типов, тестировании программы с помощью модульных тестов и анализе утилитой \textit{cppcheck}.
\subsection*{Листинги}
\begin{itemize}
\item[] \verb-queens.h-
\lstinputlisting[]
{../sources/subdirproject/lib_c/queens.h}
\item[] \verb-queens_check_for_beating.c-
\lstinputlisting[]
{../sources/subdirproject/lib_c/queens_check_for_beating.c}
\item[] \verb-queens_result_for_output.c-
\lstinputlisting[]
{../sources/subdirproject/lib_c/queens_result_for_output.c}
\item[] \verb-queens_ui.c-
\lstinputlisting[]
{../sources/subdirproject/app_c/queens_ui.c}
\end{itemize}
%##################################################################################################################################################
%
%##################################################################################################################################################
\chapter{Циклы}
\section{Задание 1. Деление уголком}
\subsection{Задание}
\hspace{\parindent}
Даны натуральные числа M и N. Вывести на экран процесс их деления с остатком
\subsection{Теоритические сведения}
%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
\hspace{\parindent}
При разработке приложения были задействованы следующие конструкции языка: оператор выбора \textbf{switch}, операторы ветвления \textbf{if} и \textbf{if-else-if}, оператор цикла с предусловием \textbf{while} и оператор цикла со счётчиком \textbf{for} -- и были использованы функции стандартной библиотеки \textit{scanf} и \textit{puts}, определённые в заголовочном файле \textit{stdio.h}; \textit{atoi}, \textit{calloc}, \textit{free}, определённые в \textit{stdlib.h}.

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
\hspace{\parindent}
При реализации алгоритма решения задачи, я воспользовался методом деления в столбик целых чисел. Конкретно в таком виде алгоритм используется в России, Франции, Бельгии и других странах.
\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
\hspace{\parindent}
В ходе проектирования было решено выделить 9 функций, 6 из которых отвечают за логику, а остальные -- за взаимодействие с пользователем.
\begin{enumerate}
\item \textbf{Логика}
\begin{itemize}
\item \verb-numlen-

Эта функция вычисляет длину числа - количество цифр в записи числа. Она имеет один целочисленный параметр - число, длину которого нужно найти. Возвращаемое значение типа int - длина числа.
\end{itemize}

\begin{itemize}
\item \verb-power-

Эта функция возводит целое число, переданное как первый аргумент, в целую степень - число переданное, как второй аргумент. Возвращат целое число - результат.
\end{itemize}

\begin{itemize}
\item \verb-n_th_dig_of_num-

Эта функция возвращает n-ую цифру числа number, где n - первый аргумент функции, а number - второй. Обращается к функциям \textit{power} и \textit{numlen}.
\end{itemize}

\begin{itemize}
\item \verb-put_number_char_by_char_to_array_with_counter-

Эта функция помещает в массив символов, который является ее первым аргуметом, посимвольно число, которое является вторым аргументом. При всем этом есть третий аргумент типа \textit{\textbf{int*}} - указатель на счетчик, который считает, сколько в массиве заполнено ячеек. Обращается к функциям numlen и \textit{n\_th\_dig\_of\_num}.
\end{itemize}

\begin{itemize}
\item \verb-put_n_symbols_to_array_with_counter-

Эта функция помещает в массив символов, который является ее первым аргуметом, n - второй целочисленный аргумент функции - символов, которые являются третьим аргументом функции. При всем этом есть четвертый аргумент типа \textbf{\textit{int*}} - указатель на счетчик, который считает, сколько в массиве заполнено ячеек.
\end{itemize}

\begin{itemize}
\item \verb-put_result_to_array-

Эта функция вычисляет результат - символьную последовательность и помещает его в массив символов. Имеет три аргумента: массив символов, в который помещается результирующая символьная последовательность; и два аргумента типа \textbf{\textit{int}} - делимое и делитель соответственно. Возвращает пустое значение. Обращается к функциям

\textit{numlen};

\textit{power};

\textit{n\_th\_dig\_of\_num};

\textit{put\_number\_char\_by\_char\_to\_array\_with\_counter};

\textit{put\_n\_symbols\_to\_array\_with\_counter}.
\end{itemize}

\textbf{\item Взаимодействие с пользователем}

\begin{itemize}
\item \verb-help_quotient-

Эта функция выводит в консоль информацию о том, как запускать приложение \textbf{Деление уголком} из параметров командной строки. Она не имеет аргументов и возвращает пустое значение. 
\end{itemize}

\begin{itemize}
\item \verb-quotient_parameters-

Эта функция отвечает за взаимодействие с пользователем при вводе данных через параметры командной строки. Она содержит 2 параметра: типа \textbf{\textit{int}} - количество аргументов командной строки и типа \textbf{\textit{char**}} - массив, содержащий эти аргументы. Считывает данные из параметров командной строки. Динамически выделяет память под массив, в который будет помещен результат. Вызывает функцию \textit{put\_result\_to\_array.} Выводит полученный массив символов в консоль. Освобождает выделенную память. Возвращаемое значение - \textit{\textbf{void}}.
\end{itemize}

\begin{itemize}
\item \verb-quotient-

Эта функция отвечает за взаимодействие с пользователем при запуске приложения в интерактивном режиме. Она не содержит аргументов. Считывает данные из консоли. Динамически выделяет память под массив, в который будет помещен результат. Вызывает функцию \textit{put\_result\_to\_array}. Выводит полученный массив символов в консоль. Освобождает выделенную память. Возвращаемое значение - \textit{\textbf{void}}.
\end{itemize}
\end{enumerate}
\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.

\begin{flushleft}
\textbf{Интегрированная среда разработки:} Qt Creator 3.5.0 (opensource)

\textbf{Компилятор:} GCC 4.9.1 20140922 (Red Hat 4.9.1-10)

\textbf{Операционная система:} Debian GNU/Linux 8 (jessie) 32-бита (version 3.14.1)
\end{flushleft}

%Ручное тестирование, автоматическое, статический анализ кода, динамический.
%\hspace{\parindent}
На всех стадиях разработки приложения проходило автоматическое тестирование c помощью модульных тестов \textit{Qt}, основанных на библиотеке  \textit{QTestLib}.

На финальной стадии был проведён статический анализ с помощью утилиты \textit{cppcheck}% и динамический анализ с помощью утилиты \textit{valgrid}.
\subsection{Тестовый план и результаты тестирования}
%Описание по шагам хода тестирования, с указанием соответствия или несоответствия ожидаемым результатам.
\hspace{\parindent}
\begin{enumerate}
\item \textbf{Модульные тесты \textit{Qt}}

\begin{description}
\item[I тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:] 128 2
\item[Выходные данные:] \verb/"128|2\n12  64\n--\n 08\n  8\n --\n  0"/
\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\item \textbf{Статический анализ \textit{cppcheck}}

Утилита \textit{cppcheck} выдала следующее предупреждение: "на 57-й строке в документе quotient\_process.c совершается операция над неинициализированной переменной".
В данной ситуации мной было предусмотрено, чтобы в итерации цикла, в которой переменная еще не инициализировалась, она не использовалась. То есть к ошибке в выполнении программы это не приводило. Тем не менее, я исправил этот недочет, и теперь \textit{cppcheck} больше не предупреждает о чем-то плохом.
\end{enumerate}
\subsection{Выводы}
\hspace{\parindent}
В ходе выполнения работы я получил опыт в использовании циклов, обработке массивов и динамическом выделении памяти.
\subsection*{Листинги}
\begin{itemize}
\item[] \verb-quotient.h-
\lstinputlisting[]
{../sources/subdirproject/lib_c/quotient.h}
\item[] \verb-quotient_process.c-
\lstinputlisting[]
{../sources/subdirproject/lib_c/quotient_process.c}
\item[] \verb-quotient_ui.c-
\lstinputlisting[]
{../sources/subdirproject/app_c/quotient_ui.c}
\end{itemize}

%##################################################################################################################################################
%
%##################################################################################################################################################
\chapter{Матрицы}
\section{Задание 1. Нули на главной диагонали}
\subsection{Задание}
\hspace{\parindent}
В каждом столбце и каждой строке матрицы P(n,n) содержится ровно один нулевой элемент. Перестановкой строк добиться расположения всех нулей по главной диагонали матрицы.
\subsection{Теоритические сведения}
%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
\hspace{\parindent}
При разработке приложения были задействованы следующие конструкции языка: оператор выбора \textbf{switch}, оператор ветвления \textbf{if}, оператор цикла со счётчиком \textbf{for} -- и были использованы функции стандартной библиотеки \textit{fopen}, \textit{fclose}, \textit{fscanf}, \textit{fprintf} и \textit{puts}, определённые в заголовочном файле \textit{stdio.h}; \textit{atoi}, \textit{malloc}, \textit{free}, определённые в \textit{stdlib.h}.

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
\hspace{\parindent}
Алгоритм решения задачи был реализован благодаря знанию такого понятия, как сортировка массива.
\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
\hspace{\parindent}
В ходе проектирования было решено выделить 5 функций, 2 из которых отвечают за логику, а остальные -- за взаимодействие с пользователем.
\begin{enumerate}
\item \textbf{Логика}
\begin{itemize}

\item \verb-level_of_null-

Эта функция определяет, в каком столбце в конкретной строке матрицы находится ноль. Имеет 2 аргумента: \textit{\textbf{int**}} - целочисленную матрицу, \textbf{\textit{int}} - ее размерность и \textbf{\textit{int}} - номер строки. Возвращает целое число - номер столбца.
\end{itemize}

\begin{itemize}
\item \verb-sort_nulls_to_the_main_diagonal-

Эта функция сортирует в матрице нули на главную диагональ. Имеет 2 аргумента: \textit{\textbf{int**}} - целочисленную матрицу и \textbf{\textit{int}} - ее размерность. Обращается к функции \textit{level\_of\_null}. Возвращает пустое значение.
\end{itemize}

\textbf{\item Взаимодействие с пользователем}

\begin{itemize}
\item \verb-matrix-

Эта функция отвечает за взаимодействие с пользователем при запуске приложения в интерактивном режиме. Она содержит два аргумента типа \textbf{\textit{char*} }- названия файлов для ввода и вывода.  Динамически выделяет память под массив, в который будет помещен результат. Вызывает функцию \textit{sort\_nulls\_to\_the\_main\_diagonal}. Выводит полученный массив символов в консоль. Освобождает выделенную память. Возвращаемое значение - \textit{\textbf{void}}.
\end{itemize}

\begin{itemize}
\item \verb-help_matrix-

Эта функция выводит в консоль информацию о том, как запускать приложение \textbf{Матрица} из параметров командной строки. Она не имеет аргументов и возвращает пустое значение. 
\end{itemize}

\begin{itemize}
\item \verb-matrix_parameters-

Эта функция отвечает за взаимодействие с пользователем при вводе данных через параметры командной строки. Она содержит 2 параметра: типа \textbf{\textit{int}} - количество аргументов командной строки и типа \textbf{\textit{char**}} - массив, содержащий эти аргументы. Считывает данные из параметров командной строки - названия файлов, из которых осуществляется ввод массива, и в которые осуществляется вывод обработанного массива. Вызывает функцию \textit{matrix}. Возвращаемое значение - \textit{\textbf{void}}.
\end{itemize}
\end{enumerate}
\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.

\begin{flushleft}
\textbf{Интегрированная среда разработки:} Qt Creator 3.5.0 (opensource)

\textbf{Компилятор:} GCC 4.9.1 20140922 (Red Hat 4.9.1-10)

\textbf{Операционная система:} Debian GNU/Linux 8 (jessie) 32-бита (version 3.14.1)
\end{flushleft}

%Ручное тестирование, автоматическое, статический анализ кода, динамический.
%\hspace{\parindent}
На всех стадиях разработки приложения проходило автоматическое тестирование c помощью модульных тестов \textit{Qt}, основанных на библиотеке  \textit{QTestLib}.

На финальной стадии был проведён статический анализ с помощью утилиты \textit{cppcheck}% и динамический анализ с помощью утилиты \textit{valgrid}.
\subsection{Тестовый план и результаты тестирования}
%Описание по шагам хода тестирования, с указанием соответствия или несоответствия ожидаемым результатам.
\hspace{\parindent}
\begin{enumerate}
\item \textbf{Модульные тесты \textit{Qt}}

\begin{description}
\item[I тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:]

\hspace{\parindent}
\begin{flushleft}
5

1 1 1 0 1

1 0 3 4 5

1 3 5 7 0

0 4 7 10 13

1 5 0 13 17
\end{flushleft}

\item[Выходные данные:]
\hspace{\parindent}
\begin{flushleft}
0 4 7 10 13

1 0 3 4 5

1 5 0 13 17

1 1 1 0 1

1 3 5 7 0
\end{flushleft}
\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\item \textbf{Статический анализ \textit{cppcheck}}

Утилита \textit{cppcheck} не выдала никаких предупреждений.
\end{enumerate}
\subsection{Выводы}
\hspace{\parindent}
В ходе выполнения работы я получил опыт в обработке матрицы и в работе с файлами.
\subsection*{Листинги}
\begin{itemize}
\item[] \verb-matrix.h-
\lstinputlisting[]
{../sources/subdirproject/lib_c/matrix.h}
\item[] \verb-matrix_processing.c-
\lstinputlisting[]
{../sources/subdirproject/lib_c/matrix_processing.c}
\item[] \verb-matrix_ui.c-
\lstinputlisting[]
{../sources/subdirproject/app_c/matrix_ui.c}
\end{itemize}


%##################################################################################################################################################
%
%##################################################################################################################################################
\chapter{Строки}
\section{Задание 1. Отцентровать текст}
\subsection{Задание}
\hspace{\parindent}
Каждую строку заданного текста вывести на экран симметрично относительно его центра.
\subsection{Теоритические сведения}
%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
\hspace{\parindent}
При разработке приложения были задействованы следующие конструкции языка: оператор выбора \textbf{switch}, оператор ветвления \textbf{if}, оператор цикла со счётчиком \textbf{for}, оператор цикла с предусловием \textbf{while} -- и были использованы функции стандартной библиотеки \textit{fopen}, \textit{fclose}, \textit{fgets}, \textit{fputs} и \textit{puts}, определённые в заголовочном файле \textit{stdio.h}; \textit{atoi}, \textit{calloc}, \textit{free}, определённые в \textit{stdlib.h}; \textit{strlen}, \textit{memset} и \textit{strcat}, определённые в \textit{string.h}.

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
\hspace{\parindent}
Мне не раз приходилось центровать текст в текстовых редакторах, поэтому именно этот опыт стал основой для реализации алгоритма решения задачи.
\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
\hspace{\parindent}
В ходе проектирования было решено выделить 5 функций, 2 из которых отвечают за логику, а остальные -- за взаимодействие с пользователем.
\begin{enumerate}
\item \textbf{Логика}
\begin{itemize}

\item \verb-determine_file_proportions-

Эта функция открывает файл, проходит по тексту, лежащему в нем, и определяет число строк и максимальную длину строки в этом тексте, а затем закрывает файл. Она имеет три аргумента: \textit{\textbf{char*}} - имя файла, \textit{\textbf{int*}} - указатель на число строк и \textit{\textbf{int*}} - указатель на максимальную длину строки. Возвращает значение типа \textit{\textbf{void}}.
\end{itemize}

\begin{itemize}
\item \verb-symmetrize_line-

Эта функция добавляет в начало строки необходимое число пробелов. Она имеет 3 аргумента: \textit{\textbf{char*}} - строка, в которую помещается результат; \textit{\textbf{char*}} - исходная строка; \textit{\textbf{int}}  - максимальная длина строки в тексте. Возвращает пустое значение.
\end{itemize}

\textbf{\item Взаимодействие с пользователем}

\begin{itemize}
\item \verb-help_lines_symmetrization-

Эта функция выводит в консоль информацию о том, как запускать приложение \textbf{Центрирование строк} из параметров командной строки. Она не имеет аргументов и возвращает пустое значение. 
\end{itemize}

\begin{itemize}
\item \verb-lines_symmetrization_parameters-

Эта функция отвечает за взаимодействие с пользователем при вводе данных через параметры командной строки. Она содержит 2 параметра: типа \textbf{\textit{int}} - количество аргументов командной строки и типа \textbf{\textit{char**}} - массив, содержащий эти аргументы. Считывает данные из параметров командной строки - названия файлов, из которых осуществляется ввод строк текста, и в которые осуществляется вывод обработанных строк текста. Вызывает функции \textit{determine\_file\_proportions} и \textit{symmetrize\_line}. Возвращаемое значение - \textit{\textbf{void}}.
\end{itemize}

\begin{itemize}
\item \verb-lines_symmetrization-

Эта функция отвечает за взаимодействие с пользователем при запуске приложения в интерактивном режиме. Она содержит два аргумента типа \textbf{\textit{char*} }- названия файлов для ввода и вывода.  Динамически выделяет память под строки, в которые будет происходить запись с файла, и в которые будут записываться обработанные строки. Вызывает функции \textit{determine\_file\_proportions} и \textit{symmetrize\_line}. Выводит полученный текст построчно в консоль. Освобождает выделенную память. Возвращаемое значение - \textit{\textbf{void}}.
\end{itemize}


\end{enumerate}
\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.

\begin{flushleft}
\textbf{Интегрированная среда разработки:} Qt Creator 3.5.0 (opensource)

\textbf{Компилятор:} GCC 4.9.1 20140922 (Red Hat 4.9.1-10)

\textbf{Операционная система:} Debian GNU/Linux 8 (jessie) 32-бита (version 3.14.1)
\end{flushleft}

%Ручное тестирование, автоматическое, статический анализ кода, динамический.
%\hspace{\parindent}
На всех стадиях разработки приложения проходило автоматическое тестирование c помощью модульных тестов \textit{Qt}, основанных на библиотеке  \textit{QTestLib}.

На финальной стадии был проведён статический анализ с помощью утилиты \textit{cppcheck}% и динамический анализ с помощью утилиты \textit{valgrid}.
\subsection{Тестовый план и результаты тестирования}
%Описание по шагам хода тестирования, с указанием соответствия или несоответствия ожидаемым результатам.
\hspace{\parindent}
\begin{enumerate}
\item \textbf{Модульные тесты \textit{Qt}}

\begin{description}
\item[I тест]
\hspace{\parindent}
\begin{flushleft}
\begin{description}
\item[Входные данные:] \verb-"sdfjl sfvslk ! asdf"- 30


\item[Выходные данные:] \verb-"     sdfjl sfvslk ! asdf"-

\item[Результат:] Тест успешно пройден
\end{description}
\end{flushleft}
\end{description}

\item \textbf{Статический анализ \textit{cppcheck}}

Утилита \textit{cppcheck} не выдала никаких предупреждений.
\end{enumerate}
\subsection{Выводы}
\hspace{\parindent}
В ходе работы я получил опыт в обработке строк, а также укрепил навык работы с файлами.
\subsection*{Листинги}
\begin{itemize}
\item[] \verb-lines_symmetrization.h-
\lstinputlisting[]
{../sources/subdirproject/lib_c/lines_symmetrization.h}
\item[] \verb-lines_symmetrization_processing.c-
\lstinputlisting[]
{../sources/subdirproject/lib_c/lines_symmetrization_processing.c}
\item[] \verb-lines_symmetrization_ui.c-
\lstinputlisting[]
{../sources/subdirproject/app_c/lines_symmetrization_ui.c}
\end{itemize}
%################################################################################################################
%
%################################################################################################################

\chapter{Приложение к главам 1 - 4}

\section{Листинги}
\begin{itemize}
\item[] \verb-main.h-
\lstinputlisting[]
{../sources/subdirproject/app_c/main.h}

\item[] \verb-help_ui.c-
\lstinputlisting[]
{../sources/subdirproject/app_c/help_ui.c}

\item[] \verb-menu.c-
\lstinputlisting[]
{../sources/subdirproject/app_c/menu.c}

\item[] \verb-main.c-
\lstinputlisting[]
{../sources/subdirproject/lib_c/lines_symmetrization_processing.c}

\item[] \verb-tst_qt_teststest.cpp-
\lstinputlisting[]
{../sources/subdirproject/qt_tests_c/tst_qt_teststest.cpp}
\end{itemize}
%################################################################################################################
%
%################################################################################################################

\chapter{Введение в классы С++}
\section{Задание 1. Инкапсуляция. Таблица-ключ-значение}
\subsection{Задание}
\hspace{\parindent}
Реализовать класс ТАБЛИЦА КЛЮЧ-ЗНАЧЕНИЕ (хранит строки, каждой из которых соответствует уникальный целый ключ). Требуемые методы: конструктор, деструктор, копирование, индексация по ключу, добавление нового элемента.
\subsection{Теоритические сведения}
%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
\hspace{\parindent}
При разработке приложения была задействована объектная ориентированность языка C++. 

\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.
\hspace{\parindent}
В ходе проектирования было решено выделить 2 класса, 1 из которых отвечают за логику, а другой -- за взаимодействие с пользователем.
\begin{enumerate}
\item \textbf{Класс с логикой Table}
\hspace{\parindent}

Были выделены методы: \textit{Table()} - конструктор, \~Table()- деструктор, \textit{Table(const Table\&)} - конструтор копирования, \textit{put(string*, int*)} - добавление нового элемента и \textit{operator[](int)} - перегруженный оператор индексирования для индексирования по ключу.
Также были выделены вспомогательные методы.
\textbf{\item Класс взаимодействия с пользователем TableApp}
\hspace{\parindent}

Были выделены методы \textit{putCellKey()} - интерфейс для добавления нового элемента, \textit{findCellByKey()} - интерфейс для индексирования по ключу, \textit{copyObject()} - интерфейс для копирования объекта.

\end{enumerate}
\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.

\begin{flushleft}
\textbf{Интегрированная среда разработки:} Qt Creator 3.5.0 (opensource)

\textbf{Компилятор:} GCC 4.9.1 20140922 (Red Hat 4.9.1-10)

\textbf{Операционная система:} Debian GNU/Linux 8 (jessie) 32-бита (version 3.14.1)
\end{flushleft}

%Ручное тестирование, автоматическое, статический анализ кода, динамический.
%\hspace{\parindent}
На всех стадиях разработки приложения проходило автоматическое тестирование c помощью модульных тестов \textit{Qt}, основанных на библиотеке  \textit{QTestLib}.

На финальной стадии был проведён статический анализ с помощью утилиты \textit{cppcheck}% и динамический анализ с помощью утилиты \textit{valgrid}.
\subsection{Тестовый план и результаты тестирования}
%Описание по шагам хода тестирования, с указанием соответствия или несоответствия ожидаемым результатам.
\hspace{\parindent}
\begin{enumerate}
\item \textbf{Модульные тесты \textit{Qt}}

Модульными тестами была протестиована работоспособность методов. Все требуемые методы - добавление элемента, копирование объекта, индексирование по ключу, конструктор и деструктор - работают.
\item \textbf{Статический анализ \textit{cppcheck}}

Утилита \textit{cppcheck} не выдала никаких предупреждений.
\end{enumerate}
\subsection{Выводы}
\hspace{\parindent}
Я познакомился с языком С++. Познакомился с новой парадигмой программирования - ООП.
\subsection*{Листинги}
\begin{itemize}
\item[] \verb-table.h-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/table.h}

\item[] \verb-table.cpp-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/table.cpp}

\item[] \verb-tableApp.h-
\lstinputlisting[]
{../sources/subdirproject/app_cpp/tableApp.h}

\item[] \verb-tableApp.cpp-
\lstinputlisting[]
{../sources/subdirproject/app_cpp/tableApp.cpp}
\end{itemize}

%################################################################################################################
%
%################################################################################################################

\chapter{Классы С++}
\section{Задание 1. Реализовать классы для всех приложений}
\subsection{Задание}
\hspace{\parindent}
Реализовать классы для всех приложений. Поработать с потоками.
\subsection{Выводы}
\hspace{\parindent}
Получил опыт создания классов. Получил опыт в работе с потоками.
\subsection*{Листинги}
\begin{itemize}


\item[] \verb-exchange.h-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/exchange.h}

\item[] \verb-exchange.cpp-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/exchange.cpp}

\item[] \verb-queens.h-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/queens.h}

\item[] \verb-queens.cpp-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/queens.cpp}

\item[] \verb-longDivision.h-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/longDivision.h}

\item[] \verb-longDivision.cpp-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/longDivision.cpp}

\item[] \verb-matrix.h-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/matrix.h}

\item[] \verb-matrix.cpp-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/matrix.cpp}

\item[] \verb-text.h-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/text.h}

\item[] \verb-text.cpp-
\lstinputlisting[]
{../sources/subdirproject/lib_cpp/text.cpp}

\item[] \verb-matrixapp.h-
\lstinputlisting[]
{../sources/subdirproject/app_cpp/matrixapp.h}

\item[] \verb-matrixapp.cpp-
\lstinputlisting[]
{../sources/subdirproject/app_cpp/matrixapp.cpp}

\item[] \verb-main.cpp-
\lstinputlisting[]
{../sources/subdirproject/app_cpp/main.cpp}

\item[] \verb-testcpp.cpp-
\lstinputlisting[]
{../sources/subdirproject/testcpp/testcpp.cpp}
\end{itemize}
\end{document}

